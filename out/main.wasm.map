{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","main.ts","~lib/math.ts","~lib/builtins.ts","~lib/array.ts","~lib/internal/arraybuffer.ts","~lib/memory.ts","~lib/internal/memory.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\nexport const AL_BITS: u32 = 3;\r\n/** Number of possible alignment values. */\r\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n/** Mask to obtain just the alignment bits. */\r\nexport const AL_MASK: usize = AL_SIZE - 1;\r\n/** Maximum 32-bit allocation size. */\r\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","/**\r\n * Arena Memory Allocator\r\n *\r\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\r\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/arena\r\n *//***/\r\n\r\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\r\n\r\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\nvar offset: usize = startOffset;\r\n\r\n// Memory allocator interface\r\n\r\n@global export function __memory_allocate(size: usize): usize {\r\n  if (size > MAX_SIZE_32) unreachable();\r\n  var ptr = offset;\r\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  if (newPtr > <usize>pagesBefore << 16) {\r\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\r\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n    if (memory.grow(pagesWanted) < 0) {\r\n      if (memory.grow(pagesNeeded) < 0) {\r\n        unreachable(); // out of memory\r\n      }\r\n    }\r\n  }\r\n  offset = newPtr;\r\n  return ptr;\r\n}\r\n\r\n@global export function __memory_free(ptr: usize): void { /* nop */ }\r\n\r\n@global export function __memory_reset(): void {\r\n  offset = startOffset;\r\n}\r\n","import \"allocator/arena\";\n\n// declare function sayHello(): void;\n\n// sayHello();\n\nexport function add(x: i32, y: i32): i32 {\n  return x + y;\n}\n\nexport function power(base: i32, exponent: i32): i32 {\n  return (base ** exponent) as i32;\n}\n\nclass MemoItem {\n  count: i32;\n  result: i32;\n}\n\nlet fibMemo: MemoItem[] = [];\n\nfunction memoExists(count: i32): i32 {\n  for (let i = 0; i < fibMemo.length; i++) {\n    let element: MemoItem = fibMemo[i];\n    if(element.count === count) {\n      return element.result;\n    }\n  }\n  return -1;\n}\nexport function fib(count: i32): i32 {\n  if(count === 1 || count === 2) {\n    return 1;\n  } else {\n    let memoEntry: i32 = memoExists(count);\n    if(memoEntry !== -1) {\n      return memoEntry;\n    } else {\n      let result: i32 = fib(count-1) + fib(count - 2);\n      fibMemo.push({count, result});\n      return result;\n    }\n  }\n}\n\nexport function fastFib(count: i32): f64 {\n  if(count === 1 || count === 2) {\n    return 1;\n  } else {\n    let a: f64 = 1;\n    let b: f64 = 1;\n    for (let i = 3; i <= count; i++) {\n      let temp: f64 = a + b;\n      b = a;\n      a = temp;\n    }\n    return a;\n  }\n}\n","import * as JSMath from \"./bindings/Math\";\r\nexport { JSMath };\r\n\r\nimport {\r\n  abs as builtin_abs,\r\n  ceil as builtin_ceil,\r\n  clz as builtin_clz,\r\n  copysign as builtin_copysign,\r\n  floor as builtin_floor,\r\n  max as builtin_max,\r\n  min as builtin_min,\r\n  sqrt as builtin_sqrt,\r\n  trunc as builtin_trunc\r\n} from \"./builtins\";\r\n\r\n// SUN COPYRIGHT NOTICE\r\n//\r\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\r\n// Developed at SunPro, a Sun Microsystems, Inc. business.\r\n// Permission to use, copy, modify, and distribute this software\r\n// is freely granted, provided that this notice is preserved.\r\n//\r\n// Applies to all functions marked with a comment referring here.\r\n\r\n// TODO: sin, cos, tan\r\n\r\n/** @internal */\r\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\r\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\r\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\r\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\r\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\r\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\r\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\r\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\r\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\r\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\r\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\r\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\r\n  return p / q;\r\n}\r\n\r\n@inline /** @internal */\r\nfunction expo2(x: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                       // see: musl/src/math/__expo2.c\r\n    k    = <u32>2043,\r\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\r\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\r\n  return NativeMath.exp(x - kln2) * scale * scale;\r\n}\r\n\r\nvar random_seeded = false;\r\nvar random_state0_64: u64;\r\nvar random_state1_64: u64;\r\nvar random_state0_32: u32;\r\nvar random_state1_32: u32;\r\n\r\n/** @internal */\r\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\r\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\r\n  h *= 0xFF51AFD7ED558CCD;\r\n  h ^= h >> 33;\r\n  h *= 0xC4CEB9FE1A85EC53;\r\n  h ^= h >> 33;\r\n  return h;\r\n}\r\n\r\n/** @internal */\r\nfunction splitMix32(h: u32): u32 {\r\n  h += 0x6D2B79F5;\r\n  h  = (h ^ (h >> 15)) * (h | 1);\r\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\r\n  return h ^ (h >> 14);\r\n}\r\n\r\nexport namespace NativeMath {\r\n\r\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\r\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\r\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\r\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\r\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\r\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\r\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\r\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\r\n\r\n  @inline\r\n  export function abs(x: f64): f64 {\r\n    return builtin_abs<f64>(x);\r\n  }\r\n\r\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\r\n    }\r\n    var s: f64, w: f64, z: f64;\r\n    if (hx >> 31) {\r\n      // z = (1.0 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f64>(z);\r\n      w = R(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1.0 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f64>(z);\r\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = R(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\r\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\r\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\r\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\r\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\r\n      return x + x * R(x * x);\r\n    }\r\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\r\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z);\r\n    var r = R(z);\r\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\r\n    else {\r\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n      let c = (z - f * f) / (s + f);\r\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\r\n    }\r\n    if (hx >> 31) return -x;\r\n    return x;\r\n  }\r\n\r\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\r\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\r\n    if (e >= 0x3FF + 26) y = log(y) + c;\r\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\r\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\r\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\r\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\r\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\r\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\r\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\r\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\r\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\r\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\r\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\r\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\r\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\r\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\r\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\r\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\r\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\r\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\r\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\r\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f64;\r\n    if (ix >= 0x44100000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign<f64>(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3FDC0000) {\r\n      if (ix < 0x3E400000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f64>(x);\r\n      if (ix < 0x3FF30000) {\r\n        if (ix < 0x3FE60000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x40038000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\r\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign<f64>(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var s = u >> 63;\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    var y = reinterpret<f64>(u);\r\n    if (e < 0x3FF - 1) {\r\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\r\n    } else {\r\n      y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    }\r\n    return builtin_copysign<f64>(y, x);\r\n  }\r\n\r\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\r\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var lx = <u32>u;\r\n    u = reinterpret<u64>(y);\r\n    var iy = <u32>(u >> 32);\r\n    var ly = <u32>u;\r\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\r\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\r\n    ix = ix & 0x7FFFFFFF;\r\n    iy = iy & 0x7FFFFFFF;\r\n    if ((iy | ly) == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return  y;\r\n        case 2: return  PI;\r\n        case 3: return -PI;\r\n      }\r\n    }\r\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\r\n    if (ix == 0x7FF00000) {\r\n      if (iy == 0x7FF00000) {\r\n        switch (m) {\r\n          case 0: return  PI / 4;\r\n          case 1: return -PI / 4;\r\n          case 2: return  3 * PI / 4;\r\n          case 3: return -3 * PI / 4;\r\n        }\r\n      } else {\r\n        switch (m) {\r\n          case 0: return  0.0;\r\n          case 1: return -0.0;\r\n          case 2: return  PI;\r\n          case 3: return -PI;\r\n        }\r\n      }\r\n    }\r\n    var z: f64;\r\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\r\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\r\n    else z = atan(builtin_abs<f64>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return PI - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - PI;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1     = <u32>715094163,\r\n      B2     = <u32>696219795,\r\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\r\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\r\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\r\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\r\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\r\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n    if (hx >= 0x7FF00000) return x + x;\r\n    if (hx < 0x00100000) {\r\n      u = reinterpret<u64>(x * Ox1p54);\r\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n      if (hx == 0) return x;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 1 << 63;\r\n    u |= <u64>hx << 32;\r\n    var t = reinterpret<f64>(u);\r\n    var r = (t * t) * (t / x);\r\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\r\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\r\n    var s = t * t;\r\n    r = x / s;\r\n    var w = t + t;\r\n    r = (r - t) / (w + r);\r\n    t = t + t * r;\r\n    return t;\r\n  }\r\n\r\n  @inline\r\n  export function ceil(x: f64): f64 {\r\n    return builtin_ceil<f64>(x);\r\n  }\r\n\r\n  @inline\r\n  export function clz32(x: f64): f64 {\r\n    return <f64>builtin_clz<i32>(<i32>x);\r\n  }\r\n\r\n  export function cos(x: f64): f64 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    x = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w < 0x3FE62E42) {\r\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\r\n      t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (w < 0x40862E42) {\r\n      t = exp(x);\r\n      return 0.5 * (t + 1 / t);\r\n    }\r\n    t = expo2(x);\r\n    return t;\r\n  }\r\n\r\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n      ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n      invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n      P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n      P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n      P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n      P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n      overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\r\n      underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\r\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var sign_ = <i32>(hx >> 31);\r\n    hx &= 0x7FFFFFFF;\r\n    if (hx >= 0x4086232B) {\r\n      if (isNaN(x)) return x;\r\n      if (x > overflow) {\r\n        x *= Ox1p1023;\r\n        return x;\r\n      }\r\n      if (x < underflow) return 0;\r\n    }\r\n    var hi: f64, lo: f64 = 0;\r\n    var k = 0;\r\n    if (hx > 0x3FD62E42) {\r\n      if (hx >= 0x3FF0A2B2) {\r\n        k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\r\n      } else {\r\n        k = 1 - (sign_ << 1);\r\n      }\r\n      hi = x - k * ln2hi;\r\n      lo = k * ln2lo;\r\n      x = hi - lo;\r\n    } else if (hx > 0x3E300000) {\r\n      hi = x;\r\n    } else return 1.0 + x;\r\n    var xs = x * x;\r\n    // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\r\n    var xq = xs * xs;\r\n    var c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\r\n    var y = 1.0 + (x * c / (2 - c) - lo + hi);\r\n    if (k == 0) return y;\r\n    return scalbn(y, k);\r\n  }\r\n\r\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\r\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\r\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\r\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\r\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\r\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\r\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\r\n    var k = 0, sign_ = <i32>(u >> 63);\r\n    if (hx >= 0x4043687A) {\r\n      if (isNaN(x)) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) return x * Ox1p1023;\r\n    }\r\n    var c = 0.0, t: f64;\r\n    if (hx > 0x3FD62E42) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\r\n        hx < 0x3FF0A2B2\r\n      );\r\n      t = <f64>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x3C900000) return x;\r\n    var hfx = 0.5 * x;\r\n    var hxs = x * hfx;\r\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\r\n    var hxq = hxs * hxs;\r\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\r\n    t = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x3FF + k) << 52;\r\n    var twopk = reinterpret<f64>(u);\r\n    var y: f64;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x3FF - k) << 52;\r\n    y = reinterpret<f64>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  @inline\r\n  export function floor(x: f64): f64 {\r\n    return builtin_floor<f64>(x);\r\n  }\r\n\r\n  @inline\r\n  export function fround(x: f64): f32 {\r\n    return <f32>x;\r\n  }\r\n\r\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\r\n    const\r\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\r\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\r\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    ux &= 0x7FFFFFFFFFFFFFFF;\r\n    uy &= 0x7FFFFFFFFFFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    var ex = <i32>(ux >> 52);\r\n    var ey = <i32>(uy >> 52);\r\n    y = reinterpret<f64>(uy);\r\n    if (ey == 0x7FF) return y;\r\n    x = reinterpret<f64>(ux);\r\n    if (ex == 0x7FF || uy == 0) return x;\r\n    if (ex - ey > 64) return x + y;\r\n    var z = 1.0;\r\n    if (ex > 0x3FF + 510) {\r\n      z  = Ox1p700;\r\n      x *= Ox1p_700;\r\n      y *= Ox1p_700;\r\n    } else if (ey < 0x3FF - 450) {\r\n      z  = Ox1p_700;\r\n      x *= Ox1p700;\r\n      y *= Ox1p700;\r\n    }\r\n    var c = x * SPLIT;\r\n    var h = x - c + c;\r\n    var l = x - h;\r\n    var hx = x * x;\r\n    var lx = h * h - hx + (2 * h + l) * l;\r\n    c = y * SPLIT;\r\n    h = y - c + c;\r\n    l = y - h;\r\n    var hy = y * y;\r\n    var ly = h * h - hy + (2 * h + l) * l;\r\n    return z * builtin_sqrt(ly + lx + hy + hx);\r\n  }\r\n\r\n  export function imul(x: f64, y: f64): f64 {\r\n    return <f64>(<i32>x * <i32>y);\r\n  }\r\n\r\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31)    return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += (<i32>hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var dk = k;\r\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\r\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\r\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\r\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\r\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31) return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += <i32>(hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var hi = f - hfsq;\r\n    u = reinterpret<u64>(hi);\r\n    u &= 0xFFFFFFFF00000000;\r\n    hi = reinterpret<f64>(u);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var val_hi = hi * ivln10hi;\r\n    var dk = <f64>k;\r\n    var y = dk * log10_2hi;\r\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\r\n    w = y + val_hi;\r\n    val_lo += (y - w) + val_hi;\r\n    return val_lo + w;\r\n  }\r\n\r\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 1;\r\n    var c = 0.0, f = 0.0;\r\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\r\n      if (hx >= 0xBFF00000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (hx << 1 < 0x3CA00000 << 1) return x;\r\n      if (hx <= 0xBFD2BEC4) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (hx >= 0x7FF00000) return x;\r\n    if (k) {\r\n      u = reinterpret<u64>(1 + x);\r\n      let hu = <u32>(u >> 32);\r\n      hu += 0x3FF00000 - 0x3FE6A09E;\r\n      k = <i32>(hu >> 20) - 0x3FF;\r\n      if (k < 54) {\r\n        let uf = reinterpret<f64>(u);\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\r\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\r\n      f = reinterpret<f64>(u) - 1;\r\n    }\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var dk = <f64>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\r\n      ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\r\n      Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54  = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31) return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) return x;\r\n      else if (hx == 0x3FF00000 && u << 32 == 0) return 0;\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += <i32>(hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var hi = f - hfsq;\r\n    u = reinterpret<u64>(hi);\r\n    u &= 0xFFFFFFFF00000000;\r\n    hi = reinterpret<f64>(u);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var val_hi = hi * ivln2hi;\r\n    var val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\r\n    var y = <f64>k;\r\n    w = y + val_hi;\r\n    val_lo += (y - w) + val_hi;\r\n    val_hi = w;\r\n    return val_lo + val_hi;\r\n  }\r\n\r\n  @inline\r\n  export function max(value1: f64, value2: f64): f64 {\r\n    return builtin_max<f64>(value1, value2);\r\n  }\r\n\r\n  @inline\r\n  export function min(value1: f64, value2: f64): f64 {\r\n    return builtin_min<f64>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\r\n      dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\r\n      two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\r\n      huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\r\n      tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\r\n      L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\r\n      L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\r\n      L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\r\n      L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\r\n      L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\r\n      L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\r\n      P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n      P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n      P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n      P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n      P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n      lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\r\n      lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\r\n      lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\r\n      ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\r\n      cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\r\n      cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\r\n      cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\r\n      ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\r\n      ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\r\n      inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\r\n    var u_ = reinterpret<u64>(x);\r\n    var hx = <i32>(u_ >> 32);\r\n    var lx = <u32>u_;\r\n    u_ = reinterpret<u64>(y);\r\n    var hy = <i32>(u_ >> 32);\r\n    var ly = <u32>u_;\r\n    var ix = hx & 0x7FFFFFFF;\r\n    var iy = hy & 0x7FFFFFFF;\r\n    if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\r\n    // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\r\n    if ( // NaN if either arg is NaN\r\n      ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\r\n      iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\r\n    ) return x + y;\r\n    var yisint = 0, k: i32;\r\n    if (hx < 0) {\r\n      if (iy >= 0x43400000) yisint = 2;\r\n      else if (iy >= 0x3FF00000) {\r\n        k = (iy >> 20) - 0x3FF;\r\n        let offset = select<i32>(52, 20, k > 20) - k;\r\n        let Ly = select<i32>(ly, iy, k > 20);\r\n        let jj = Ly >> offset;\r\n        if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\r\n      }\r\n    }\r\n    if (ly == 0) {\r\n      if (iy == 0x7FF00000) { // y is +-inf\r\n        if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\r\n        else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\r\n        else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\r\n      }\r\n      if (iy == 0x3FF00000) {\r\n        if (hy >= 0) return x;\r\n        return 1 / x;\r\n      }\r\n      if (hy == 0x40000000) return x * x;\r\n      if (hy == 0x3FE00000) {\r\n        if (hx >= 0) return builtin_sqrt(x);\r\n      }\r\n    }\r\n    var ax = builtin_abs<f64>(x), z: f64;\r\n    if (lx == 0) {\r\n      if (ix == 0x7FF00000 || ix == 0 || ix == 0x3FF00000) {\r\n        z = ax;\r\n        if (hy < 0) z = 1.0 / z;\r\n        if (hx < 0) {\r\n          if (((ix - 0x3FF00000) | yisint) == 0) z = (z - z) / (z - z);\r\n          else if (yisint == 1) z = -z;\r\n        }\r\n        return z;\r\n      }\r\n    }\r\n    var s = 1.0;\r\n    if (hx < 0) {\r\n      if (yisint == 0) return (x - x) / (x - x);\r\n      if (yisint == 1) s = -1.0;\r\n    }\r\n    var t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\r\n    var j: i32, n: i32;\r\n    if (iy > 0x41E00000) {\r\n      if (iy > 0x43F00000) {\r\n        if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\r\n        if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\r\n      }\r\n      if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\r\n      if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\r\n      t = ax - 1.0;\r\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\r\n      u = ivln2_h * t;\r\n      v = t * ivln2_l - w * ivln2;\r\n      t1 = u + v;\r\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n      t2 = v - (t1 - u);\r\n    } else {\r\n      let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\r\n      n = 0;\r\n      if (ix < 0x00100000) {\r\n        ax *= two53;\r\n        n -= 53;\r\n        ix = <u32>(reinterpret<u64>(ax) >> 32);\r\n      }\r\n      n += (ix >> 20) - 0x3FF;\r\n      j = ix & 0x000FFFFF;\r\n      ix = j | 0x3FF00000;\r\n      if (j <= 0x3988E) k = 0;\r\n      else if (j < 0xBB67A) k = 1;\r\n      else {\r\n        k = 0;\r\n        n += 1;\r\n        ix -= 0x00100000;\r\n      }\r\n      ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\r\n      let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\r\n      u = ax - bp;\r\n      v = 1.0 / (ax + bp);\r\n      ss = u * v;\r\n      s_h = ss;\r\n      s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\r\n      t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\r\n      t_l = ax - (t_h - bp);\r\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\r\n      s2 = ss * ss;\r\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\r\n      r += s_l * (s_h + ss);\r\n      s2 = s_h * s_h;\r\n      t_h = 3.0 + s2 + r;\r\n      t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\r\n      t_l = r - ((t_h - 3.0) - s2);\r\n      u = s_h * t_h;\r\n      v = s_l * t_h + t_l * ss;\r\n      p_h = u + v;\r\n      p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\r\n      p_l = v - (p_h - u);\r\n      let z_h = cp_h * p_h;\r\n      let dp_l = select<f64>(dp_l1, 0.0, k);\r\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\r\n      t = <f64>n;\r\n      let dp_h = select<f64>(dp_h1, 0.0, k);\r\n      t1 = ((z_h + z_l) + dp_h) + t;\r\n      t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\r\n    }\r\n    var y1 = y;\r\n    y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\r\n    p_l = (y - y1) * t1 + y * t2;\r\n    p_h = y1 * t1;\r\n    z = p_l + p_h;\r\n    u_ = reinterpret<u64>(z);\r\n    j = <u32>(u_ >> 32);\r\n    var i = <i32>u_;\r\n    if (j >= 0x40900000) {\r\n      if (((j - 0x40900000) | i) != 0) return s * huge * huge;\r\n      if (p_l + ovt > z - p_h) return s * huge * huge;\r\n    } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\r\n      if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\r\n      if (p_l <= z - p_h) return s * tiny * tiny;\r\n    }\r\n    i = j & 0x7FFFFFFF;\r\n    k = (i >> 20) - 0x3FF;\r\n    n = 0;\r\n    if (i > 0x3FE00000) {\r\n      n = j + (0x00100000 >> (k + 1));\r\n      k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\r\n      t = 0.0;\r\n      t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\r\n      n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\r\n      if (j < 0) n = -n;\r\n      p_h -= t;\r\n    }\r\n    t = p_l + p_h;\r\n    t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\r\n    u = t * lg2_h;\r\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\r\n    z = u + v;\r\n    w = v - (z - u);\r\n    t = z * z;\r\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\r\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\r\n    z = 1.0 - (r - z);\r\n    j = <u32>(reinterpret<u64>(z) >> 32);\r\n    j += n << 20;\r\n    if ((j >> 20) <= 0) z = scalbn(z, n);\r\n    else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\r\n    return s * z;\r\n  }\r\n\r\n  export function seedRandom(value: i64): void {\r\n    assert(value);\r\n    random_seeded = true;\r\n    random_state0_64 = murmurHash3(value);\r\n    random_state1_64 = murmurHash3(~random_state0_64);\r\n    random_state0_32 = splitMix32(<u32>value);\r\n    random_state1_32 = splitMix32(random_state0_32);\r\n  }\r\n\r\n  export function random(): f64 { // see: v8/src/base/random-number-generator.cc\r\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\r\n    var s1 = random_state0_64;\r\n    var s0 = random_state1_64;\r\n    random_state0_64 = s0;\r\n    s1 ^= s1 << 23;\r\n    s1 ^= s1 >> 17;\r\n    s1 ^= s0;\r\n    s1 ^= s0 >> 26;\r\n    random_state1_64 = s1;\r\n    var r = ((s0 + s1) & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000;\r\n    return reinterpret<f64>(r) - 1;\r\n  }\r\n\r\n  @inline\r\n  export function round(x: f64): f64 {\r\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\r\n  }\r\n\r\n  @inline\r\n  export function sign(x: f64): f64 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  export function signbit(x: f64): bool {\r\n    // In ECMAScript all NaN values are indistinguishable from each other\r\n    // so we need handle NaN and negative NaN in similar way\r\n    return <bool>(<i32>(reinterpret<u64>(x) >>> 63) & (x == x));\r\n  }\r\n\r\n  export function sin(x: f64): f64 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\r\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\r\n    var absx = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    var h = builtin_copysign(0.5, x);\r\n    if (w < 0x40862E42) {\r\n      t = expm1(absx);\r\n      if (w < 0x3FF00000) {\r\n        if (w < 0x3FF00000 - (26 << 20)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    t = 2 * h * expo2(absx);\r\n    return t;\r\n  }\r\n\r\n  @inline\r\n  export function sqrt(x: f64): f64 {\r\n    return builtin_sqrt<f64>(x);\r\n  }\r\n\r\n  export function tan(x: f64): f64 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    var y = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w > 0x3FE193EA) {\r\n      if (w > 0x40340000) {\r\n        t = 1 - 0 / y;\r\n      } else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (w > 0x3FD058AE) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (w >= 0x00100000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f64>(t, x);\r\n  }\r\n\r\n  @inline\r\n  export function trunc(x: f64): f64 {\r\n    return builtin_trunc<f64>(x);\r\n  }\r\n\r\n  /** @internal */\r\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\r\n    const\r\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\r\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\r\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\r\n    var y = x;\r\n    if (n > 1023) {\r\n      y *= Ox1p1023;\r\n      n -= 1023;\r\n      if (n > 1023) {\r\n        y *= Ox1p1023;\r\n        n = builtin_min<i32>(n - 1023, 1023);\r\n      }\r\n    } else if (n < -1022) {\r\n      /* make sure final n < -53 to avoid double\r\n\t\t   rounding in the subnormal range */\r\n      y *= Ox1p_1022 * Ox1p53;\r\n      n += 1022 - 53;\r\n      if (n < -1022) {\r\n        y *= Ox1p_1022 * Ox1p53;\r\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\r\n      }\r\n    }\r\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\r\n  }\r\n\r\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = ux >> 63;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) return (x * y) / (x * y);\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      if (ux1 == uy1) return 0 * x;\r\n      return x;\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(ux << 12);\r\n      ux <<= -ex + 1;\r\n    } else {\r\n      ux &= <u64>-1 >> 12;\r\n      ux |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 52); ux <<= 1) --ex;\r\n    var shift = builtin_clz<i64>(ux << 11);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 52;\r\n      ux |= ex << 52;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    ux |= sx << 63;\r\n    return reinterpret<f64>(ux);\r\n  }\r\n\r\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = <i32>(ux >> 63);\r\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) return (x * y) / (x * y);\r\n    if (ux << 1 == 0) return x;\r\n    var uxi = ux;\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(uxi << 12);\r\n      uxi <<= -ex + 1;\r\n    } else {\r\n      uxi &= <u64>-1 >> 12;\r\n      uxi |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    var q: u32 = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -60;\r\n      else {\r\n        let shift = builtin_clz<i64>(uxi << 11);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n  // end:\r\n    if (ex > 0) {\r\n      uxi -= 1 << 52;\r\n      uxi |= ex << 52;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f64>(uxi);\r\n    y = builtin_abs<f64>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // ++q;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n}\r\n\r\n/** @internal */\r\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\r\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\r\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\r\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\r\n  var p = z * (pS0 + z * (pS1 + z * pS2));\r\n  var q: f32 = 1 + z * qS1;\r\n  return p / q;\r\n}\r\n\r\n@inline /** @internal */\r\nfunction expo2f(x: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                        // see: musl/src/math/__expo2f.c\r\n    k    = <u32>235,\r\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\r\n  var scale = reinterpret<f32>(<u32>(0x7F + k / 2) << 23);\r\n  return NativeMathf.exp(x - kln2) * scale * scale;\r\n}\r\n\r\nexport namespace NativeMathf {\r\n\r\n  export const E       = <f32>NativeMath.E;\r\n  export const LN2     = <f32>NativeMath.LN2;\r\n  export const LN10    = <f32>NativeMath.LN10;\r\n  export const LOG2E   = <f32>NativeMath.LOG2E;\r\n  export const LOG10E  = <f32>NativeMath.LOG10E;\r\n  export const PI      = <f32>NativeMath.PI;\r\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\r\n  export const SQRT2   = <f32>NativeMath.SQRT2;\r\n\r\n  @inline\r\n  export function abs(x: f32): f32 {\r\n    return builtin_abs<f32>(x);\r\n  }\r\n\r\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\r\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = reinterpret<u32>(x);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3F800000) {\r\n      if (ix == 0x3F800000) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3F000000) {\r\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\r\n    }\r\n    var z: f32, w: f32, s: f32;\r\n    if (hx >> 31) {\r\n      // z = (1 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f32>(z);\r\n      w = Rf(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f32>(z);\r\n    hx = reinterpret<u32>(s);\r\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = Rf(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\r\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x);\r\n    var a = u & 0x7FFFFFFF;\r\n    if (a < 0x3F800000 + (1 << 23)) {\r\n      let xm1 = x - 1;\r\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\r\n    }\r\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var sx = x;\r\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    if (hx >= 0x3F800000) {\r\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (hx < 0x3F000000) {\r\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\r\n      return x + x * Rf(x * x);\r\n    }\r\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\r\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z); // sic\r\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\r\n    return builtin_copysign(x, sx);\r\n  }\r\n\r\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\r\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\r\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\r\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\r\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\r\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\r\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\r\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\r\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\r\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\r\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\r\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\r\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\r\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\r\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\r\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = reinterpret<u32>(x);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f32;\r\n    if (ix >= 0x4C800000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3EE00000) {\r\n      if (ix < 0x39800000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f32>(x);\r\n      if (ix < 0x3F980000) {\r\n        if (ix < 0x3F300000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x401C0000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\r\n    var s2 = w * (aT1 + w * aT3);\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    if (u < 0x3F800000 - (1 << 23)) {\r\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\r\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\r\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var ix = reinterpret<u32>(x);\r\n    var iy = reinterpret<u32>(y);\r\n    if (ix == 0x3F800000) return atan(y);\r\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\r\n    ix &= 0x7FFFFFFF;\r\n    iy &= 0x7FFFFFFF;\r\n    if (iy == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return y;\r\n        case 2: return  pi;\r\n        case 3: return -pi;\r\n      }\r\n    }\r\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\r\n    if (ix == 0x7F800000) {\r\n      if (iy == 0x7F800000) {\r\n        switch (m) {\r\n          case 0: return  pi / 4;\r\n          case 1: return -pi / 4;\r\n          case 2: return  3 * pi / 4;\r\n          case 3: return -3 * pi / 4;\r\n        }\r\n      } else {\r\n        switch (m) {\r\n          case 0: return  0;\r\n          case 1: return -0;\r\n          case 2: return  pi;\r\n          case 3: return -pi;\r\n        }\r\n      }\r\n    }\r\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\r\n    var z: f32;\r\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\r\n    else z = atan(builtin_abs<f32>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return pi - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - pi;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1      = <u32>709958130,\r\n      B2      = <u32>642849266,\r\n      Ox1p24f = reinterpret<f32>(0x4B800000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    if (hx >= 0x7F800000) return x + x;\r\n    if (hx < 0x00800000) {\r\n      if (hx == 0) return x;\r\n      u = reinterpret<u32>(x * Ox1p24f);\r\n      hx = u & 0x7FFFFFFF;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 0x80000000;\r\n    u |= hx;\r\n    var t = <f64>reinterpret<f32>(u);\r\n    var r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    return <f32>t;\r\n  }\r\n\r\n  @inline\r\n  export function ceil(x: f32): f32 {\r\n    return builtin_ceil<f32>(x);\r\n  }\r\n\r\n  @inline\r\n  export function clz32(x: f32): f32 {\r\n    return <f32>builtin_clz<i32>(<i32>x);\r\n  }\r\n\r\n  export function cos(x: f32): f32 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    x = reinterpret<f32>(u);\r\n    if (u < 0x3F317217) {\r\n      if (u < 0x3F800000 - (12 << 23)) return 1;\r\n      let t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (u < 0x42B17217) {\r\n      let t = exp(x);\r\n      // return 0.5 * (t + 1 / t);\r\n      return 0.5 * t + 0.5 / t;\r\n    }\r\n    return expo2f(x);\r\n  }\r\n\r\n  @inline\r\n  export function floor(x: f32): f32 {\r\n    return builtin_floor<f32>(x);\r\n  }\r\n\r\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\r\n      ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\r\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\r\n      P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\r\n      P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\r\n      Ox1p127f = reinterpret<f32>(0x7F000000);\r\n    var hx = reinterpret<u32>(x);\r\n    var sign_ = <i32>(hx >> 31);\r\n    hx &= 0x7FFFFFFF;\r\n    if (hx >= 0x42AEAC50) {\r\n      if (hx >= 0x42B17218) {\r\n        if (!sign_) {\r\n          x *= Ox1p127f;\r\n          return x;\r\n        } else {\r\n          if (hx >= 0x42CFF1B5) return 0;\r\n        }\r\n      }\r\n    }\r\n    var hi: f32, lo: f32;\r\n    var k: i32;\r\n    if (hx > 0x3EB17218) {\r\n      if (hx > 0x3F851592) {\r\n        k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\r\n      } else {\r\n        k = 1 - (sign_ << 1);\r\n      }\r\n      hi = x - <f32>k * ln2hi;\r\n      lo = <f32>k * ln2lo;\r\n      x = hi - lo;\r\n    } else if (hx > 0x39000000) {\r\n      k = 0;\r\n      hi = x;\r\n      lo = 0;\r\n    } else {\r\n      return 1 + x;\r\n    }\r\n    var xx = x * x;\r\n    var c = x - xx * (P1 + xx * P2);\r\n    var y: f32 = 1 + (x * c / (2 - c) - lo + hi);\r\n    if (k == 0) return y;\r\n    return scalbn(y, k);\r\n  }\r\n\r\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\r\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\r\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\r\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\r\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\r\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\r\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    var sign_ = <i32>(u >> 31);\r\n    if (hx >= 0x4195B844) {\r\n      if (hx > 0x7F800000) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) {\r\n        x *= Ox1p127f;\r\n        return x;\r\n      }\r\n    }\r\n    var c: f32 = 0.0, t: f32, k: i32;\r\n    if (hx > 0x3EB17218) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\r\n        hx < 0x3F851592\r\n      );\r\n      t = <f32>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x33000000) {\r\n      return x;\r\n    } else k = 0;\r\n    var hfx: f32 = 0.5 * x;\r\n    var hxs: f32 = x * hfx;\r\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\r\n    t  = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e  = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x7F + k) << 23;\r\n    var twopk = reinterpret<f32>(u);\r\n    var y: f32;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 128) y = y * 2.0 * Ox1p127f;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x7F - k) << 23;\r\n    y = reinterpret<f32>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  @inline\r\n  export function fround(x: f32): f32 {\r\n    return x;\r\n  }\r\n\r\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\r\n    const\r\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\r\n      Ox1p_90f = reinterpret<f32>(0x12800000);\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    ux &= 0x7FFFFFFF;\r\n    uy &= 0x7FFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    x = reinterpret<f32>(ux);\r\n    y = reinterpret<f32>(uy);\r\n    if (uy == 0xFF << 23) return y;\r\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\r\n    var z: f32 = 1;\r\n    if (ux >= (0x7F + 60) << 23) {\r\n      z  = Ox1p90f;\r\n      x *= Ox1p_90f;\r\n      y *= Ox1p_90f;\r\n    } else if (uy < (0x7F - 60) << 23) {\r\n      z  = Ox1p_90f;\r\n      x *= Ox1p90f;\r\n      y *= Ox1p90f;\r\n    }\r\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\r\n  }\r\n\r\n  @inline\r\n  export function imul(x: f32, y: f32): f32 {\r\n    return <f32>(<i32>x * <i32>y);\r\n  }\r\n\r\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\r\n      ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\r\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\r\n      Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\r\n      Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\r\n      Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\r\n      Ox1p25f = reinterpret<f32>(0x4C000000);\r\n    var u = reinterpret<u32>(x);\r\n    var k = 0;\r\n    if (u < 0x00800000 || <bool>(u >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (u >> 31) return (x - x) / 0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      u = reinterpret<u32>(x);\r\n    } else if (u >= 0x7F800000) return x;\r\n      else if (u == 0x3F800000) return 0;\r\n    u += 0x3F800000 - 0x3F3504F3;\r\n    k += <u32>(<i32>u >> 23) - 0x7F;\r\n    u = (u & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(u);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq = <f32>0.5 * f * f;\r\n    var dk = <f32>k;\r\n    return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\r\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\r\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\r\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\r\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\r\n    var ix = reinterpret<u32>(x);\r\n    var k = 0;\r\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n      if (ix << 1 == 0) return -1 / (x * x);\r\n      if (ix >> 31) return (x - x) / 0.0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      ix = reinterpret<u32>(x);\r\n    } else if (ix >= 0x7F800000) return x;\r\n      else if (ix == 0x3F800000) return 0;\r\n    ix += 0x3F800000 - 0x3F3504F3;\r\n    k += <i32>(ix >> 23) - 0x7F;\r\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(ix);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var hi = f - hfsq;\r\n    ix = reinterpret<u32>(hi);\r\n    ix &= 0xFFFFF000;\r\n    hi = reinterpret<f32>(ix);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var dk = <f32>k;\r\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\r\n  }\r\n\r\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\r\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\r\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\r\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\r\n    var ix = reinterpret<u32>(x);\r\n    var c: f32 = 0, f: f32 = 0;\r\n    var k: i32 = 1;\r\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\r\n      if (ix >= 0xBF800000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (ix << 1 < 0x33800000 << 1) return x;\r\n      if (ix <= 0xBE95F619) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (ix >= 0x7F800000) return x;\r\n    if (k) {\r\n      let uf: f32 = 1 + x;\r\n      let iu = reinterpret<u32>(uf);\r\n      iu += 0x3F800000 - 0x3F3504F3;\r\n      k = <i32>(iu >> 23) - 0x7F;\r\n      if (k < 25) {\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\r\n      f = reinterpret<f32>(iu) - 1;\r\n    }\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var dk = <f32>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\r\n      ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\r\n      Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n      Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n      Ox1p25f = reinterpret<f32>(0x4C000000);\r\n    var ix = reinterpret<u32>(x);\r\n    var k: i32 = 0;\r\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n      if (ix << 1 == 0) return -1 / (x * x);\r\n      if (ix >> 31) return (x - x) / 0.0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      ix = reinterpret<u32>(x);\r\n    } else if (ix >= 0x7F800000) return x;\r\n      else if (ix == 0x3F800000) return 0;\r\n    ix += 0x3F800000 - 0x3F3504F3;\r\n    k += <i32>(ix >> 23) - 0x7F;\r\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(ix);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var hi = f - hfsq;\r\n    var u = reinterpret<u32>(hi);\r\n    u &= 0xFFFFF000;\r\n    hi = reinterpret<f32>(u);\r\n    var lo: f32 = f - hi - hfsq + s * (hfsq + r);\r\n    var dk = <f32>k;\r\n    return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\r\n  }\r\n\r\n  @inline\r\n  export function max(value1: f32, value2: f32): f32 {\r\n    return builtin_max<f32>(value1, value2);\r\n  }\r\n\r\n  @inline\r\n  export function min(value1: f32, value2: f32): f32 {\r\n    return builtin_min<f32>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f32, y: f32): f32 { // see: musl/src/math/powf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      dp_h1   = reinterpret<f32>(0x3F15C000), //  5.84960938e-01f\r\n      dp_l1   = reinterpret<f32>(0x35D1CFDC), //  1.56322085e-06f\r\n      two24   = reinterpret<f32>(0x4B800000), //  16777216f\r\n      huge    = reinterpret<f32>(0x7149F2CA), //  1.0e+30f\r\n      tiny    = reinterpret<f32>(0x0DA24260), //  1.0e-30f\r\n      L1      = reinterpret<f32>(0x3F19999A), //  6.0000002384e-01f\r\n      L2      = reinterpret<f32>(0x3EDB6DB7), //  4.2857143283e-01f\r\n      L3      = reinterpret<f32>(0x3EAAAAAB), //  3.3333334327e-01f\r\n      L4      = reinterpret<f32>(0x3E8BA305), //  2.7272811532e-01f\r\n      L5      = reinterpret<f32>(0x3E6C3255), //  2.3066075146e-01f\r\n      L6      = reinterpret<f32>(0x3E53F142), //  2.0697501302e-01f\r\n      P1      = reinterpret<f32>(0x3E2AAAAB), //  1.6666667163e-01f\r\n      P2      = reinterpret<f32>(0xBB360B61), // -2.7777778450e-03f\r\n      P3      = reinterpret<f32>(0x388AB355), //  6.6137559770e-05f\r\n      P4      = reinterpret<f32>(0xB5DDEA0E), // -1.6533901999e-06f\r\n      P5      = reinterpret<f32>(0x3331BB4C), //  4.1381369442e-08f\r\n      lg2     = reinterpret<f32>(0x3F317218), //  6.9314718246e-01f\r\n      lg2_h   = reinterpret<f32>(0x3F317200), //  6.93145752e-01f\r\n      lg2_l   = reinterpret<f32>(0x35BFBE8C), //  1.42860654e-06f\r\n      ovt     = reinterpret<f32>(0x3338AA3C), //  4.2995665694e-08f\r\n      cp      = reinterpret<f32>(0x3F76384F), //  9.6179670095e-01\r\n      cp_h    = reinterpret<f32>(0x3F764000), //  9.6191406250e-01\r\n      cp_l    = reinterpret<f32>(0xB8F623C6), // -1.1736857402e-04\r\n      ivln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00\r\n      ivln2_h = reinterpret<f32>(0x3FB8AA00), //  1.4426879883e+00\r\n      ivln2_l = reinterpret<f32>(0x36ECA570), //  7.0526075433e-06\r\n      inv3    = reinterpret<f32>(0x3EAAAAAB);  // 0.333333333333\r\n    var hx = reinterpret<i32>(x);\r\n    var hy = reinterpret<i32>(y);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    var iy = hy & 0x7FFFFFFF;\r\n    if (iy == 0) return 1.0; // x**0 = 1, even if x is NaN\r\n    // if (hx == 0x3F800000) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\r\n    if (ix > 0x7F800000 || iy > 0x7F800000) return x + y; // NaN if either arg is NaN\r\n    var yisint  = 0, j: i32, k: i32;\r\n    if (hx < 0) {\r\n      if (iy >= 0x4B800000) yisint = 2;\r\n      else if (iy >= 0x3F800000) {\r\n        k = (iy >> 23) - 0x7F;\r\n        j = iy >> (23 - k);\r\n        if ((j << (23 - k)) == iy) yisint = 2 - (j & 1);\r\n      }\r\n    }\r\n    if (iy == 0x7F800000) { // y is +-inf\r\n      if (ix == 0x3F800000) return NaN; // C: (-1)**+-inf is 1, JS: NaN\r\n      else if (ix > 0x3F800000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\r\n      else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\r\n    }\r\n    if (iy == 0x3F800000) return hy >= 0 ? x : 1.0 / x;\r\n    if (hy == 0x40000000) return x * x;\r\n    if (hy == 0x3F000000) {\r\n      if (hx >= 0) return builtin_sqrt<f32>(x);\r\n    }\r\n    var ax = builtin_abs<f32>(x);\r\n    var z: f32;\r\n    if (ix == 0x7F800000 || ix == 0 || ix == 0x3F800000) {\r\n      z = ax;\r\n      if (hy < 0) z = 1.0 / z;\r\n      if (hx < 0) {\r\n        if (((ix - 0x3F800000) | yisint) == 0) z = (z - z) / (z - z);\r\n        else if (yisint == 1) z = -z;\r\n      }\r\n      return z;\r\n    }\r\n    var sn = <f32>1.0;\r\n    if (hx < 0) {\r\n      if (yisint == 0) return (x - x) / (x - x);\r\n      if (yisint == 1) sn = -1.0;\r\n    }\r\n    var t1: f32, t2: f32, r: f32, s: f32, t: f32, u: f32, v: f32, w: f32, p_h: f32, p_l: f32;\r\n    var n: i32, is: i32;\r\n    if (iy > 0x4D000000) {\r\n      if (ix < 0x3F7FFFF8) return hy < 0 ? sn * huge * huge : sn * tiny * tiny;\r\n      if (ix > 0x3F800007) return hy > 0 ? sn * huge * huge : sn * tiny * tiny;\r\n      t = ax - 1;\r\n      w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\r\n      u = ivln2_h * t;\r\n      v = t * ivln2_l - w * ivln2;\r\n      t1 = u + v;\r\n      is = reinterpret<i32>(t1);\r\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\r\n      t2 = v - (t1 - u);\r\n    } else {\r\n      let s2: f32, s_h: f32, s_l: f32, t_h: f32, t_l: f32;\r\n      n = 0;\r\n      if (ix < 0x00800000) {\r\n        ax *= two24;\r\n        n -= 24;\r\n        ix = reinterpret<i32>(ax);\r\n      }\r\n      n += (ix >> 23) - 0x7F;\r\n      j = ix & 0x007FFFFF;\r\n      ix = j | 0x3F800000;\r\n      if (j <= 0x1CC471) k = 0;\r\n      else if (j < 0x5DB3D7) k = 1;\r\n      else {\r\n        k = 0;\r\n        n += 1;\r\n        ix -= 0x00800000;\r\n      }\r\n      ax = reinterpret<f32>(ix);\r\n      let bp = select<f32>(1.5, 1.0, k); // k ? 1.5 : 1.0\r\n      u = ax - bp;\r\n      v = 1.0 / (ax + bp);\r\n      s = u * v;\r\n      s_h = s;\r\n      is = reinterpret<u32>(s_h);\r\n      s_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      is = ((ix >> 1) & 0xFFFFF000) | 0x20000000;\r\n      t_h = reinterpret<f32>(is + 0x00400000 + (k << 21));\r\n      t_l = ax - (t_h - bp);\r\n      s_l = v * ((u - s_h * t_h) - s_h * t_l);\r\n      s2 = s * s;\r\n      r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\r\n      r += s_l * (s_h + s);\r\n      s2 = s_h * s_h;\r\n      t_h = 3.0 + s2 + r;\r\n      is  = reinterpret<u32>(t_h);\r\n      t_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      t_l = r - ((t_h - 3.0) - s2);\r\n      u = s_h * t_h;\r\n      v = s_l * t_h + t_l * s;\r\n      p_h = u + v;\r\n      is  = reinterpret<u32>(p_h);\r\n      p_h = reinterpret<f32>(is & 0xFFFFF000);\r\n      p_l = v - (p_h - u);\r\n      let z_h = cp_h * p_h;\r\n      let dp_l = select<f32>(dp_l1, 0.0, k);\r\n      let z_l = cp_l * p_h + p_l * cp + dp_l;\r\n      t = <f32>n;\r\n      let dp_h = select<f32>(dp_h1, 0.0, k);\r\n      t1 = (((z_h + z_l) + dp_h) + t);\r\n      is = reinterpret<u32>(t1);\r\n      t1 = reinterpret<f32>(is & 0xFFFFF000);\r\n      t2 = z_l - (((t1 - t) - dp_h) - z_h);\r\n    }\r\n    is = reinterpret<u32>(y);\r\n    var y1 = reinterpret<f32>(is & 0xFFFFF000);\r\n    p_l = (y - y1) * t1 + y * t2;\r\n    p_h = y1 * t1;\r\n    z = p_l + p_h;\r\n    j = reinterpret<u32>(z);\r\n    if (j > 0x43000000) {\r\n      return sn * huge * huge;\r\n    } else if (j == 0x43000000) {\r\n      if (p_l + ovt > z - p_h) return sn * huge * huge;\r\n    } else if ((j & 0x7FFFFFFF) > 0x43160000) {\r\n      return sn * tiny * tiny;\r\n    } else if (j == 0xC3160000) {\r\n      if (p_l <= z - p_h) return sn * tiny * tiny;\r\n    }\r\n    var i = j & 0x7FFFFFFF;\r\n    k = (i >> 23) - 0x7F;\r\n    n = 0;\r\n    if (i > 0x3F000000) {\r\n      n = j + (0x00800000 >> (k + 1));\r\n      k = ((n & 0x7FFFFFFF) >> 23) - 0x7F;\r\n      t = reinterpret<f32>(n & ~(0x007FFFFF >> k));\r\n      n = ((n & 0x007FFFFF) | 0x00800000) >> (23 - k);\r\n      if (j < 0) n = -n;\r\n      p_h -= t;\r\n    }\r\n    t = p_l + p_h;\r\n    is = reinterpret<u32>(t);\r\n    t = reinterpret<f32>(is & 0xFFFF8000);\r\n    u = t * lg2_h;\r\n    v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\r\n    z = u + v;\r\n    w = v - (z - u);\r\n    t = z * z;\r\n    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\r\n    r = (z * t1) / (t1 - 2.0) - (w + z * w);\r\n    z = 1.0 - (r - z);\r\n    j = reinterpret<u32>(z);\r\n    j += n << 23;\r\n    if ((j >> 23) <= 0) z = scalbn(z, n);\r\n    else z = reinterpret<f32>(j);\r\n    return sn * z;\r\n  }\r\n\r\n  @inline\r\n  export function seedRandom(value: i64): void {\r\n    NativeMath.seedRandom(value);\r\n  }\r\n\r\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\r\n  export function random(): f32 {\r\n    if (!random_seeded) throw new Error(\"PRNG must be seeded.\");\r\n\r\n    var s0 = random_state0_32;\r\n    var s1 = random_state1_32;\r\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\r\n\r\n    s1 ^= s0;\r\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\r\n    random_state1_32 = rotl<u32>(s1, 13);\r\n\r\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\r\n  }\r\n\r\n  @inline\r\n  export function round(x: f32): f32 {\r\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\r\n  }\r\n\r\n  @inline\r\n  export function sign(x: f32): f32 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  @inline\r\n  export function signbit(x: f32): bool {\r\n    return <bool>((reinterpret<u32>(x) >>> 31) & (x == x));\r\n  }\r\n\r\n  export function sin(x: f32): f32 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var absx = reinterpret<f32>(u);\r\n    var t: f32;\r\n    var h = builtin_copysign<f32>(0.5, x);\r\n    if (u < 0x42B17217) {\r\n      t = expm1(absx);\r\n      if (u < 0x3F800000) {\r\n        if (u < 0x3F800000 - (12 << 23)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    t = 2 * h * expo2f(absx);\r\n    return t;\r\n  }\r\n\r\n  @inline\r\n  export function sqrt(x: f32): f32 {\r\n    return builtin_sqrt<f32>(x);\r\n  }\r\n\r\n  export function tan(x: f32): f32 { // TODO\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    var t: f32;\r\n    if (u > 0x3F0C9F54) {\r\n      if (u > 0x41200000) t = 1 + 0 / y;\r\n      else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (u > 0x3E82C578) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (u >= 0x00800000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f32>(t, x);\r\n  }\r\n\r\n  @inline\r\n  export function trunc(x: f32): f32 {\r\n    return builtin_trunc<f32>(x);\r\n  }\r\n\r\n  /** @internal */\r\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\r\n    const\r\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\r\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\r\n      Ox1p_126f = reinterpret<f32>(0x00800000);\r\n    var y = x;\r\n    if (n > 127) {\r\n      y *= Ox1p127f;\r\n      n -= 127;\r\n      if (n > 127) {\r\n        y *= Ox1p127f;\r\n        n = builtin_min<i32>(n - 127, 127);\r\n      }\r\n    } else if (n < -126) {\r\n      y *= Ox1p_126f * Ox1p24f;\r\n      n += 126 - 24;\r\n      if (n < -126) {\r\n        y *= Ox1p_126f * Ox1p24f;\r\n        n = builtin_max<i32>(n + 126 - 24, -126);\r\n      }\r\n    }\r\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\r\n  }\r\n\r\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sx = ux & 0x80000000;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) return (x * y) / (x * y);\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      if (ux1 == uy1) return 0 * x;\r\n      return x;\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(ux << 9);\r\n      ux <<= -ex + 1;\r\n    } else {\r\n      ux &= <u32>-1 >> 9;\r\n      ux |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 23); ux <<= 1) --ex;\r\n    var shift = <i32>builtin_clz<u32>(ux << 8);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 23;\r\n      ux |= <u32>ex << 23;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    ux |= sx;\r\n    return reinterpret<f32>(ux);\r\n  }\r\n\r\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sx = <i32>(ux >> 31);\r\n    var uxi = ux;\r\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\r\n    if (ux << 1 == 0) return x;\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(uxi << 9);\r\n      uxi <<= -ex + 1;\r\n    } else {\r\n      uxi &= <u32>-1 >> 9;\r\n      uxi |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= -ey + 1;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    var q = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -30;\r\n      else {\r\n        let shift = builtin_clz<i32>(uxi << 8);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n  // end\r\n    if (ex > 0) {\r\n      uxi -= 1 << 23;\r\n      uxi |= <u32>ex << 23;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f32>(uxi);\r\n    y = builtin_abs<f32>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // q++;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n}\r\n\r\nexport function ipow32(x: i32, e: i32): i32 {\r\n  var out = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e < 0) return 0;\r\n\r\n    switch (e) {\r\n      case 0: return 1;\r\n      case 1: return x;\r\n      case 2: return x * x;\r\n    }\r\n\r\n    let log = 32 - clz(e);\r\n    if (log <= 5) {\r\n      // 32 = 2 ^ 5, so need only five cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n\r\n  while (e > 0) {\r\n    if (e & 1) out *= x;\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function ipow64(x: i64, e: i32): i64 {\r\n  var out: i64 = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e < 0) return 0;\r\n    switch (e) {\r\n      case 0: return 1;\r\n      case 1: return x;\r\n      case 2: return x * x;\r\n    }\r\n\r\n    let log = 32 - clz(e);\r\n    if (log <= 6) {\r\n      // 64 = 2 ^ 6, so need only six cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 6: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n\r\n  while (e > 0) {\r\n    if (e & 1) out *= x;\r\n    e >>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n","/* tslint:disable */\r\n\r\n@builtin @inline export const NaN: f64 = 0 / 0;\r\n@builtin @inline export const Infinity: f64 = 1 / 0;\r\n\r\n@builtin export declare function isInteger<T>(value?: T): bool;\r\n@builtin export declare function isFloat<T>(value?: T): bool;\r\n@builtin export declare function isSigned<T>(value?: T): bool;\r\n@builtin export declare function isReference<T>(value?: T): bool;\r\n@builtin export declare function isString<T>(value?: T): bool;\r\n@builtin export declare function isArray<T>(value?: T): bool;\r\n@builtin export declare function isDefined(expression: void): bool;\r\n@builtin export declare function isConstant(expression: void): bool;\r\n@builtin export declare function isManaged<T>(value?: T): bool;\r\n@inline export function isNaN<T>(value: T): bool { return value != value; }\r\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\r\n\r\n@builtin export declare function clz<T>(value: T): T;\r\n@builtin export declare function ctz<T>(value: T): T;\r\n@builtin export declare function popcnt<T>(value: T): T;\r\n@builtin export declare function rotl<T>(value: T, shift: T): T;\r\n@builtin export declare function rotr<T>(value: T, shift: T): T;\r\n@builtin export declare function abs<T>(value: T): T;\r\n@builtin export declare function max<T>(left: T, right: T): T;\r\n@builtin export declare function min<T>(left: T, right: T): T;\r\n@builtin export declare function ceil<T>(value: T): T;\r\n@builtin export declare function floor<T>(value: T): T;\r\n@builtin export declare function copysign<T>(left: T, right: T): T;\r\n@builtin export declare function nearest<T>(value: T): T;\r\n@builtin export declare function reinterpret<T>(value: void): T;\r\n@builtin export declare function sqrt<T>(value: T): T;\r\n@builtin export declare function trunc<T>(value: T): T;\r\n@builtin export declare function load<T>(offset: usize, constantOffset?: usize): T;\r\n@builtin export declare function store<T>(offset: usize, value: void, constantOffset?: usize): void;\r\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\r\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\r\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\r\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\r\n@builtin export declare function unreachable(): void;\r\n@builtin export declare function changetype<T>(value: void): T;\r\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\r\n@builtin export declare function unchecked<T>(expr: T): T;\r\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\r\n@builtin export declare function instantiate<T>(...args: void[]): T;\r\n\r\n@builtin export declare function i8(value: void): i8;\r\nexport namespace i8 {\r\n  export const MIN_VALUE: i8 = -128;\r\n  export const MAX_VALUE: i8 =  127;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): i8 { return <i8>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): i8 { return <i8>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function i16(value: void): i16;\r\nexport namespace i16 {\r\n  export const MIN_VALUE: i16 = -32768;\r\n  export const MAX_VALUE: i16 =  32767;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): i16 { return <i16>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): i16 { return <i16>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function i32(value: void): i32;\r\nexport namespace i32 {\r\n  export const MIN_VALUE: i32 = -2147483648;\r\n  export const MAX_VALUE: i32 =  2147483647;\r\n  @builtin export declare function clz(value: i32): i32;\r\n  @builtin export declare function ctz(value: i32): i32;\r\n  @builtin export declare function popcnt(value: i32): i32;\r\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\r\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\r\n  @builtin export declare function reinterpret_f32(value: f32): i32;\r\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i32;\r\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): i32;\r\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i32;\r\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): i32;\r\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i32;\r\n  @builtin export declare function store8(offset: usize, value: i32, constantOffset?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i32, constantOffset?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i32, constantOffset?: usize): void;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): i32 { return <i32>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): i32 { return <i32>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function i64(value: void): i64;\r\nexport namespace i64 {\r\n  export const MIN_VALUE: i64 = -9223372036854775808;\r\n  export const MAX_VALUE: i64 =  9223372036854775807;\r\n  @builtin export declare function clz(value: i64): i64;\r\n  @builtin export declare function ctz(value: i64): i64;\r\n  @builtin export declare function load8_s(offset: usize, constantOffset?: usize): i64;\r\n  @builtin export declare function load8_u(offset: usize, constantOffset?: usize): u64;\r\n  @builtin export declare function load16_s(offset: usize, constantOffset?: usize): i64;\r\n  @builtin export declare function load16_u(offset: usize, constantOffset?: usize): u64;\r\n  @builtin export declare function load32_s(offset: usize, constantOffset?: usize): i64;\r\n  @builtin export declare function load32_u(offset: usize, constantOffset?: usize): u64;\r\n  @builtin export declare function load(offset: usize, constantOffset?: usize): i64;\r\n  @builtin export declare function popcnt(value: i64): i64;\r\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\r\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\r\n  @builtin export declare function reinterpret_f64(value: f64): i64;\r\n  @builtin export declare function store8(offset: usize, value: i64, constantOffset?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i64, constantOffset?: usize): void;\r\n  @builtin export declare function store32(offset: usize, value: i64, constantOffset?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i64, constantOffset?: usize): void;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): i64 { return <i64>parseI64(value, radix) }\r\n  @inline export function parseFloat(value: string): i64 { return <i64>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function isize(value: void): isize;\r\nexport namespace isize {\r\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? -2147483648\r\n    : <isize>-9223372036854775808;\r\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? 2147483647\r\n    : <isize>9223372036854775807;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): isize { return <isize>parseI64(value, radix) }\r\n  @inline export function parseFloat(value: string): isize { return <isize>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function u8(value: void): u8;\r\nexport namespace u8 {\r\n  export const MIN_VALUE: u8 = 0;\r\n  export const MAX_VALUE: u8 = 255;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): u8 { return <u8>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): u8 { return <u8>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function u16(value: void): u16;\r\nexport namespace u16 {\r\n  export const MIN_VALUE: u16 = 0;\r\n  export const MAX_VALUE: u16 = 65535;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): u16 { return <u16>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): u16 { return <u16>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function u32(value: void): u32;\r\nexport namespace u32 {\r\n  export const MIN_VALUE: u32 = 0;\r\n  export const MAX_VALUE: u32 = 4294967295;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): u32 { return <u32>parseI32(value, radix) }\r\n  @inline export function parseFloat(value: string): u32 { return <u32>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function u64(value: void): u64;\r\nexport namespace u64 {\r\n  export const MIN_VALUE: u64 = 0;\r\n  export const MAX_VALUE: u64 = 18446744073709551615;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): u64 { return <u64>parseI64(value, radix) }\r\n  @inline export function parseFloat(value: string): u64 { return <u64>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function usize(value: void): usize;\r\nexport namespace usize {\r\n  export const MIN_VALUE: usize = 0;\r\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\r\n    ? 4294967295\r\n    : <usize>18446744073709551615;\r\n  @inline export function parseInt(value: string, radix: i32 = 0): usize { return <usize>parseI64(value, radix) }\r\n  @inline export function parseFloat(value: string): usize { return <usize>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function bool(value: void): bool;\r\nexport namespace bool {\r\n  export const MIN_VALUE: bool = false;\r\n  export const MAX_VALUE: bool = true;\r\n}\r\n\r\n@builtin export declare function f32(value: void): f32;\r\nexport namespace f32 {\r\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\r\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\r\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\r\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\r\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\r\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\r\n  export const POSITIVE_INFINITY: f32 =  Infinity;\r\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\r\n  export const NaN: f32 = NaN;\r\n  @builtin export declare function abs(value: f32): f32;\r\n  @builtin export declare function ceil(value: f32): f32;\r\n  @builtin export declare function copysign(x: f32, y: f32): f32;\r\n  @builtin export declare function floor(value: f32): f32;\r\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f32;\r\n  @builtin export declare function max(left: f32, right: f32): f32;\r\n  @builtin export declare function min(left: f32, right: f32): f32;\r\n  @builtin export declare function nearest(value: f32): f32;\r\n  @builtin export declare function reinterpret_i32(value: i32): f32;\r\n  @builtin export declare function sqrt(value: f32): f32;\r\n  @builtin export declare function store(offset: usize, value: f32, constantOffset?: usize): void;\r\n  @builtin export declare function trunc(value: f32): f32;\r\n  @inline  export function isNaN(value: f32): bool { return isNaN<f32>(value) }\r\n  @inline  export function isFinite(value: f32): bool { return isFinite<f32>(value) }\r\n  @inline  export function isSafeInteger(value: f32): bool { return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value }\r\n  @inline  export function isInteger(value: f32): bool { return isFinite<f32>(value) && trunc<f32>(value) == value }\r\n  @inline  export function parseInt(value: string, radix: i32 = 0): f32 { return <f32>parseI64(value, radix) }\r\n  @inline  export function parseFloat(value: string): f32 { return <f32>parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function f64(value: void): f64;\r\nexport namespace f64 {\r\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\r\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\r\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\r\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\r\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\r\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\r\n  export const POSITIVE_INFINITY: f64 =  Infinity;\r\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\r\n  export const NaN: f64 = NaN;\r\n  @builtin export declare function abs(value: f64): f64;\r\n  @builtin export declare function ceil(value: f64): f64;\r\n  @builtin export declare function copysign(x: f64, y: f64): f64;\r\n  @builtin export declare function floor(value: f64): f64;\r\n  @builtin export declare function load(offset: usize, constantOffset?: usize): f64;\r\n  @builtin export declare function max(left: f64, right: f64): f64;\r\n  @builtin export declare function min(left: f64, right: f64): f64;\r\n  @builtin export declare function nearest(value: f64): f64;\r\n  @builtin export declare function reinterpret_i64(value: i64): f64;\r\n  @builtin export declare function sqrt(value: f64): f64;\r\n  @builtin export declare function store(offset: usize, value: f64, constantOffset?: usize): void;\r\n  @builtin export declare function trunc(value: f64): f64;\r\n  @inline  export function isNaN(value: f64): bool { return isNaN<f64>(value) }\r\n  @inline  export function isFinite(value: f64): bool { return isFinite<f64>(value) }\r\n  @inline  export function isSafeInteger(value: f64): bool { return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value }\r\n  @inline  export function isInteger(value: f64): bool { return isFinite<f64>(value) && trunc<f64>(value) == value }\r\n  @inline  export function parseInt(value: string, radix: i32 = 0): f64 { return <f64>parseI64(value, radix) }\r\n  @inline  export function parseFloat(value: string): f64 { return parseFloat(value) }\r\n}\r\n\r\n@builtin export declare function start(): void;\r\n","import {\r\n  MAX_BLENGTH,\r\n  HEADER_SIZE,\r\n  allocateUnsafe,\r\n  reallocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  allocateUnsafe as allocateUnsafeString,\r\n  freeUnsafe as freeUnsafeString,\r\n  copyUnsafe as copyUnsafeString\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  COMPARATOR,\r\n  SORT\r\n} from \"./internal/sort\";\r\n\r\nimport {\r\n  itoa,\r\n  dtoa,\r\n  itoa_stream,\r\n  dtoa_stream,\r\n  MAX_DOUBLE_LENGTH\r\n} from \"./internal/number\";\r\n\r\nimport {\r\n  isArray as builtin_isArray\r\n} from \"./builtins\";\r\n\r\nexport class Array<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  /* @internal */ buffer_: ArrayBuffer;\r\n  /* @internal */ length_: i32;\r\n\r\n  @inline static isArray<U>(value: U): bool {\r\n    return builtin_isArray(value) && value !== null;\r\n  }\r\n\r\n  constructor(length: i32 = 0) {\r\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    this.buffer_ = buffer;\r\n    this.length_ = length;\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      0,\r\n      <usize>byteLength\r\n    );\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.length_;\r\n  }\r\n\r\n  set length(length: i32) {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>length > <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = length;\r\n  }\r\n\r\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (!callbackfn(LOAD<T>(buffer, index), index, this)) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (predicate(LOAD<T>(buffer, index), index, this)) return index;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): T {\r\n    var buffer = this.buffer_;\r\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\r\n      ? LOAD<T>(buffer, index)\r\n      : <T>unreachable();\r\n  }\r\n\r\n  @operator(\"{}\")\r\n  private __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer_, index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: T): void {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>index >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\r\n      this.buffer_ = buffer;\r\n      this.length_ = index + 1;\r\n    }\r\n    STORE<T>(buffer, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  @operator(\"{}=\")\r\n  private __unchecked_set(index: i32, value: T): void {\r\n    STORE<T>(this.buffer_, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len    = this.length_;\r\n\r\n    start = start < 0 ? max(len + start, 0) : min(start, len);\r\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n\r\n    if (sizeof<T>() == 1) {\r\n      if (start < end) {\r\n        memory.fill(\r\n          changetype<usize>(buffer) + start + HEADER_SIZE,\r\n          <u8>value,\r\n          <usize>(end - start)\r\n        );\r\n      }\r\n    } else {\r\n      for (; start < end; ++start) {\r\n        STORE<T>(buffer, start, value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  @inline\r\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\r\n    return this.indexOf(searchElement, fromIndex) >= 0;\r\n  }\r\n\r\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length_;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    var buffer = this.buffer_;\r\n    while (fromIndex < length) {\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\r\n    var length = this.length_;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    var buffer = this.buffer_;\r\n    while (fromIndex >= 0) {                           // ^\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(element: T): i32 {\r\n    var length = this.length_;\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = newLength;\r\n    STORE<T>(buffer, length, element);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  concat(items: Array<T>): Array<T> {\r\n    var thisLen = this.length_;\r\n    var otherLen = items === null ? 0 : items.length_;\r\n    var outLen = thisLen + otherLen;\r\n    var out = new Array<T>(outLen);\r\n\r\n    if (thisLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\r\n        <usize>thisLen << alignof<T>()\r\n      );\r\n    }\r\n    if (otherLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\r\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\r\n        <usize>otherLen << alignof<T>()\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len = this.length_;\r\n\r\n        end   = min<i32>(end, len);\r\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n    var count = min(last - from, len - to);\r\n\r\n    if (from < to && to < (from + count)) {\r\n      from += count - 1;\r\n      to   += count - 1;\r\n      while (count) {\r\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\r\n        --from, --to, --count;\r\n      }\r\n    } else {\r\n      memory.copy(\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\r\n        <usize>count << alignof<T>()\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  pop(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var element = LOAD<T>(this.buffer_, --length);\r\n    this.length_ = length;\r\n    return element;\r\n  }\r\n\r\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < toIndex && index < this.length_; ++index) {\r\n      callbackfn(LOAD<T>(buffer, index), index, this);\r\n    }\r\n  }\r\n\r\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\r\n    var buffer = this.buffer_;\r\n    var length = this.length_;\r\n    var result = new Array<U>(length);\r\n    var resultBuffer = result.buffer_;\r\n    for (let index = 0; index < min(length, this.length_); ++index) {\r\n      STORE<U>(resultBuffer, index, callbackfn(LOAD<T>(buffer, index), index, this));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\r\n    var buffer = this.buffer_;\r\n    var result = new Array<T>();\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      let value = LOAD<T>(buffer, index);\r\n      if (callbackfn(value, index, this)) result.push(value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reduce<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  reduceRight<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    var buffer = this.buffer_;\r\n    for (let index: i32 = this.length_ - 1; index >= 0; --index) {\r\n      accum = callbackfn(accum, LOAD<T>(buffer, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  shift(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var buffer = this.buffer_;\r\n    var element = LOAD<T>(buffer, 0);\r\n    var lastIndex = length - 1;\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      <usize>lastIndex << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, lastIndex, <T>null);\r\n    this.length_ = lastIndex;\r\n    return element;\r\n  }\r\n\r\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    var buffer = this.buffer_;\r\n    for (let index = 0, toIndex = this.length_; index < min(toIndex, this.length_); ++index) {\r\n      if (callbackfn(LOAD<T>(buffer, index), index, this)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  unshift(element: T): i32 {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var length = this.length_;\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      capacity = buffer.byteLength >>> alignof<T>();\r\n      this.buffer_ = buffer;\r\n    }\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      <usize>(capacity - 1) << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, 0, element);\r\n    this.length_ = newLength;\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length = this.length_;\r\n    if (begin < 0) begin = max(length + begin, 0);\r\n    else if (begin > length) begin = length;\r\n    if (end < 0) end = length + end; // no need to clamp\r\n    else if (end > length) end = length;\r\n    if (end < begin) end = begin;    // ^\r\n    var newLength = end - begin;\r\n    assert(newLength >= 0);\r\n    var sliced = new Array<T>(newLength);\r\n    if (newLength) {\r\n      memory.copy(\r\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\r\n        <usize>newLength << alignof<T>()\r\n      );\r\n    }\r\n    return sliced;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length  = this.length_;\r\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\r\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\r\n    var buffer  = this.buffer_;\r\n    var spliced = new Array<T>(deleteCount);\r\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\r\n    memory.copy(\r\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\r\n      source,\r\n      <usize>deleteCount << alignof<T>()\r\n    );\r\n    var offset = start + deleteCount;\r\n    if (length != offset) {\r\n      memory.copy(\r\n        source,\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\r\n        <usize>(length - offset) << alignof<T>()\r\n      );\r\n    }\r\n    this.length_ = length - deleteCount;\r\n    return spliced;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    var buffer = this.buffer_;\r\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\r\n      let temp = LOAD<T>(buffer, front);\r\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\r\n      STORE<T>(buffer, back, temp);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\r\n    // TODO remove this when flow will allow trackcing null\r\n    assert(comparator); // The comparison function must be a function\r\n\r\n    var length = this.length_;\r\n    if (length <= 1) return this;\r\n    var buffer = this.buffer_;\r\n    if (length == 2) {\r\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\r\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\r\n      if (comparator(a, b) < 0) {\r\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\r\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\r\n      }\r\n      return this;\r\n    }\r\n    SORT<T>(buffer, 0, length, comparator);\r\n    return this;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    var lastIndex = this.length_ - 1;\r\n    if (lastIndex < 0) return \"\";\r\n    var result = \"\";\r\n    var value: T;\r\n    var buffer = this.buffer_;\r\n    var sepLen = separator.length;\r\n    var hasSeparator = sepLen != 0;\r\n    if (value instanceof bool) {\r\n      if (!lastIndex) {\r\n        return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\r\n      }\r\n      let valueLen = 5; // max possible length of element len(\"false\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,bool>(buffer, i);\r\n        valueLen = 4 + <i32>(!value);\r\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n        offset += valueLen;\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,bool>(buffer, lastIndex);\r\n      valueLen = 4 + <i32>(!value);\r\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n      offset += valueLen;\r\n\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isInteger<T>()) {\r\n      if (!lastIndex) {\r\n        return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\r\n      }\r\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isFloat<T>()) {\r\n      if (!lastIndex) {\r\n        return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\r\n      }\r\n      const valueLen = MAX_DOUBLE_LENGTH;\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,f64>(buffer, i);\r\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,f64>(buffer, lastIndex);\r\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isString<T>()) {\r\n      if (!lastIndex) {\r\n        return LOAD<string>(buffer, 0);\r\n      }\r\n      let estLen = 0;\r\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\r\n        estLen += LOAD<string>(buffer, i).length;\r\n      }\r\n      let offset = 0;\r\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<string>(buffer, i);\r\n        if (value) {\r\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<string>(buffer, lastIndex);\r\n      if (value) {\r\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n      }\r\n      return result;\r\n    } else if (isArray<T>()) {\r\n      if (!lastIndex) {\r\n        value = LOAD<T>(buffer, 0);\r\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\r\n      }\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n        if (hasSeparator) result += separator;\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n      return result;\r\n    } else if (isReference<T>()) { // References\r\n      if (!lastIndex) return \"[object Object]\";\r\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) {\r\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n          offset += valueLen;\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      if (LOAD<T>(buffer, lastIndex)) {\r\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n        offset += valueLen;\r\n      }\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else {\r\n      assert(false); // Unsupported generic typename\r\n    }\r\n  }\r\n\r\n  @inline\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  private __gc(): void {\r\n    var buffer = this.buffer_;\r\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\r\n    if (isManaged<T>()) {\r\n      let offset: usize = 0;\r\n      let end = <usize>this.length_ << alignof<usize>();\r\n      while (offset < end) {\r\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\r\n        offset += sizeof<usize>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  AL_MASK,\r\n  MAX_SIZE_32\r\n } from \"./allocator\";\r\n\r\n/** Size of an ArrayBuffer header. */\r\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\r\n/** Maximum byte length of an ArrayBuffer. */\r\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\r\n\r\nfunction computeSize(byteLength: i32): usize {\r\n  // round up to power of 2, with HEADER_SIZE=8:\r\n  // 0            -> 2^3  = 8\r\n  // 1..8         -> 2^4  = 16\r\n  // 9..24        -> 2^5  = 32\r\n  // ...\r\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\r\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\r\n}\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\r\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<ArrayBuffer>()) {\r\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(computeSize(byteLength));\r\n  }\r\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  return changetype<ArrayBuffer>(buffer);\r\n}\r\n\r\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\r\n  var oldByteLength = buffer.byteLength;\r\n  if (newByteLength > oldByteLength) {\r\n    assert(newByteLength <= MAX_BLENGTH);\r\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\r\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n    } else { // slow path: copy to new buffer\r\n      let newBuffer = allocateUnsafe(newByteLength);\r\n      memory.copy(\r\n        changetype<usize>(newBuffer) + HEADER_SIZE,\r\n        changetype<usize>(buffer) + HEADER_SIZE,\r\n        <usize>oldByteLength\r\n      );\r\n      if (!isManaged<ArrayBuffer>()) {\r\n        memory.free(changetype<usize>(buffer));\r\n      }\r\n      buffer = newBuffer;\r\n    }\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\r\n      0,\r\n      <usize>(newByteLength - oldByteLength)\r\n    );\r\n  } else if (newByteLength < oldByteLength) { // fast path: override size\r\n    // TBD: worth to copy and release if size is significantly less than before?\r\n    assert(newByteLength >= 0);\r\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  }\r\n  return buffer;\r\n}\r\n\r\n// The helpers below use two different types in order to emit loads and stores that load respectively\r\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\r\n// emit instructions like\r\n//\r\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\r\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\r\n//\r\n// without having to emit an additional instruction for conversion purposes. The second parameter\r\n// can be omitted for references and other loads and stores that simply return the exact type.\r\n\r\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\r\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\r\n}\r\n\r\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\r\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\r\n\r\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\r\n\r\n/* tslint:disable */\r\n\r\nexport namespace memory {\r\n\r\n  @builtin export declare function size(): i32;\r\n\r\n  @builtin export declare function grow(pages: i32): i32;\r\n\r\n  @inline export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    if (isDefined(__memory_fill)) { __memory_fill(dest, c, n); return; }\r\n    memset(dest, c, n);\r\n  }\r\n\r\n  @inline export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    if (isDefined(__memory_copy)) { __memory_copy(dest, src, n); return; }\r\n    memmove(dest, src, n);\r\n  }\r\n\r\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    if (isDefined(__memory_compare)) return __memory_compare(vl, vr, n);\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  @inline export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  @inline export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  @inline export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\r\n    unreachable();\r\n  }\r\n}\r\n","// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n"]}